---
sidebar_position: 3
title: HIE Integration
description: How Argus uses HIE files for type-aware analysis
---

# HIE Integration

HIE (Haskell Interface Extended) files provide rich type information that enables Argus to perform semantic analysis beyond simple pattern matching.

## What are HIE Files?

HIE files (`.hie`) are generated by GHC and contain:

- **Type information**: Types for every expression
- **Source spans**: Precise location mapping
- **References**: Where names are defined and used
- **Scopes**: Lexical scope information
- **Module structure**: Exports, imports, dependencies

## Generating HIE Files

### Stack

```yaml
# stack.yaml
ghc-options:
  "$locals": -fwrite-ide-info -hiedir=.hie
```

Or command-line:

```bash
stack build --ghc-options="-fwrite-ide-info -hiedir=.hie"
```

### Cabal

```bash
cabal build --ghc-options="-fwrite-ide-info -hiedir=.hie"
```

Or in `cabal.project`:

```
program-options
  ghc-options: -fwrite-ide-info -hiedir=.hie
```

## HIE File Structure

```haskell
data HieFile = HieFile
  { hie_hs_file   :: FilePath         -- Source file path
  , hie_module    :: Module           -- Module name
  , hie_types     :: Array TypeIndex Type  -- Type table
  , hie_asts      :: HieASTs          -- Annotated AST
  , hie_exports   :: [AvailInfo]      -- Module exports
  , hie_hs_src    :: ByteString       -- Original source
  }

data HieAST a = HieAST
  { nodeSpan     :: Span             -- Source location
  , nodeInfo     :: NodeInfo a       -- Type and scope info
  , nodeChildren :: [HieAST a]       -- Child nodes
  }

data NodeInfo a = NodeInfo
  { nodeAnnotations :: Set NodeAnnotation
  , nodeType        :: [a]           -- Type indices
  , nodeIdentifiers :: Map Identifier IdentifierDetails
  }
```

## Loading HIE Files

### Index Building

```haskell
data HIEIndex = HIEIndex
  { hieFiles    :: Map ModuleName HieFile
  , hieTypes    :: TypeIndex
  , hieRefs     :: RefIndex
  , hieExports  :: ExportIndex
  }

buildIndex :: FilePath -> IO HIEIndex
buildIndex hieDir = do
  files <- findHieFiles hieDir
  loaded <- mapM loadHieFile files
  return $ indexHieFiles loaded

findHieFiles :: FilePath -> IO [FilePath]
findHieFiles dir = glob (dir </> "**/*.hie")
```

### Lazy Loading

```haskell
-- Load on demand
data LazyHIE = LazyHIE
  { lazyPath :: FilePath
  , lazyHie  :: IORef (Maybe HieFile)
  }

getHieFile :: LazyHIE -> IO HieFile
getHieFile lazy = do
  cached <- readIORef (lazyHie lazy)
  case cached of
    Just hie -> return hie
    Nothing -> do
      hie <- loadHieFile (lazyPath lazy)
      writeIORef (lazyHie lazy) (Just hie)
      return hie
```

## Type Queries

### Get Type at Location

```haskell
getTypeAt :: SrcSpan -> HIEIndex -> Maybe Type
getTypeAt span idx = do
  hie <- lookupModule (spanModule span) idx
  ast <- findAstAt span (hie_asts hie)
  typeIdx <- listToMaybe (nodeType (nodeInfo ast))
  return $ hie_types hie ! typeIdx
```

### Example: Type-Aware Head Detection

```haskell
-- Without HIE: Match any `head $X`
-- With HIE: Only match when $X has type [a] (not NonEmpty)

checkHeadUsage :: HsExpr -> HIEContext -> Maybe Diagnostic
checkHeadUsage expr@(HsApp _ (HsVar _ name) arg) hie
  | occNameString (nameOccName name) == "head" = do
      argType <- getTypeAt (getSpan arg) hie
      if isList argType  -- Not NonEmpty
        then Just $ headWarning expr
        else Nothing  -- NonEmpty.head is safe
  | otherwise = Nothing
```

## Reference Analysis

### Find All References

```haskell
findReferences :: Name -> HIEIndex -> [SrcSpan]
findReferences name idx =
  [ span
  | hie <- Map.elems (hieFiles idx)
  , ast <- toList (hie_asts hie)
  , (ident, details) <- Map.toList (nodeIdentifiers (nodeInfo ast))
  , identifierName ident == name
  , Use `elem` identifierDetails details
  , let span = nodeSpan ast
  ]
```

### Find Definition

```haskell
findDefinition :: Name -> HIEIndex -> Maybe SrcSpan
findDefinition name idx =
  listToMaybe
    [ nodeSpan ast
    | hie <- Map.elems (hieFiles idx)
    , ast <- toList (hie_asts hie)
    , (ident, details) <- Map.toList (nodeIdentifiers (nodeInfo ast))
    , identifierName ident == name
    , Decl `elem` identifierDetails details
    ]
```

## Scope Analysis

### Get Local Bindings

```haskell
getBindingsInScope :: SrcSpan -> HIEIndex -> Map Name Type
getBindingsInScope span idx = do
  hie <- lookupModule (spanModule span) idx
  ast <- findAstAt span (hie_asts hie)
  collectBindings ast
  where
    collectBindings ast =
      let local = Map.fromList
            [ (name, ty)
            | (ident, details) <- Map.toList (nodeIdentifiers (nodeInfo ast))
            , Binding `elem` identifierDetails details
            , let name = identifierName ident
            , ty <- lookupType (nodeType (nodeInfo ast)) (hie_types hie)
            ]
      in Map.unions (local : map collectBindings (nodeChildren ast))
```

### Check If Name is Exported

```haskell
isExported :: Name -> HIEIndex -> Bool
isExported name idx =
  case lookupModule (nameModule name) idx of
    Nothing -> False
    Just hie -> name `elem` exportedNames (hie_exports hie)
```

## Cross-Module Analysis

### Find Unused Exports

```haskell
findUnusedExports :: HIEIndex -> [(Module, Name)]
findUnusedExports idx =
  [ (mod, name)
  | (mod, hie) <- Map.toList (hieFiles idx)
  , name <- exportedNames (hie_exports hie)
  , not (isUsedElsewhere name idx)
  ]

isUsedElsewhere :: Name -> HIEIndex -> Bool
isUsedElsewhere name idx =
  any (usesName name) (Map.elems (hieFiles idx))
  where
    usesName n hie =
      nameModule n /= hie_module hie &&
      not (null (findRefsIn n hie))
```

### Dependency Analysis

```haskell
getModuleDependencies :: Module -> HIEIndex -> [Module]
getModuleDependencies mod idx =
  case Map.lookup mod (hieFiles idx) of
    Nothing -> []
    Just hie ->
      [ importedModule imp
      | ast <- toList (hie_asts hie)
      , (ident, _) <- Map.toList (nodeIdentifiers (nodeInfo ast))
      , Just mod <- [getIdentifierModule ident]
      , mod /= hie_module hie
      ]
```

## Type-Aware Rules

### Example: Detect String vs Text

```haskell
stringVsTextRule :: Rule
stringVsTextRule = Rule
  { ruleId = "performance/string-text"
  , ruleChecker = \mod hie -> do
      case hie of
        Nothing -> []  -- Need HIE for type info
        Just ctx ->
          [ Diagnostic span Warning msg
          | (span, ty) <- getAllTypedSpans ctx
          , isStringType ty
          , inPerformanceCriticalContext span ctx
          ]
  }

isStringType :: Type -> Bool
isStringType ty = case ty of
  TyConApp tc [] | occNameString (tyConOcc tc) == "String" -> True
  ListTy charTy | isCharType charTy -> True
  _ -> False
```

### Example: Detect Redundant Constraints

```haskell
redundantConstraintRule :: Rule
redundantConstraintRule = Rule
  { ruleId = "redundant/constraint"
  , ruleChecker = \mod hie -> do
      case hie of
        Nothing -> []
        Just ctx ->
          [ Diagnostic span Suggestion msg
          | func <- moduleFunctions mod
          , let declaredConstraints = getFunctionConstraints func
          , let usedConstraints = getUsedConstraints func ctx
          , constraint <- declaredConstraints
          , constraint `notElem` usedConstraints
          ]
  }
```

## Performance Considerations

### Memory Usage

HIE files can be large:

| Project Size | HIE Size | Loaded Memory |
|--------------|----------|---------------|
| 10K LOC | ~50 MB | ~100 MB |
| 100K LOC | ~500 MB | ~1 GB |
| 1M LOC | ~5 GB | ~10 GB |

### Lazy Loading Strategy

```haskell
-- Only load HIE files when needed
analyzeWithHIE :: Config -> FilePath -> IO [Diagnostic]
analyzeWithHIE config file = do
  -- First pass: syntax-only
  syntacticDiags <- analyzeSyntactic config file

  -- Only load HIE if needed
  if needsSemanticAnalysis syntacticDiags config
    then do
      hie <- loadHieForFile file
      semanticDiags <- analyzeSemantic config file hie
      return (syntacticDiags ++ semanticDiags)
    else return syntacticDiags
```

### Incremental Updates

```haskell
-- Track which HIE files changed
updateIndex :: HIEIndex -> [FilePath] -> IO HIEIndex
updateIndex idx changedFiles = do
  -- Remove old entries
  let cleaned = foldr removeHie idx changedFiles
  -- Load new HIE files
  newHies <- mapM loadHieFile changedFiles
  -- Merge into index
  return $ foldr addHie cleaned newHies
```

## GHC Version Compatibility

HIE format changes between GHC versions:

| GHC Version | HIE Version |
|-------------|-------------|
| 9.8 | 1.9 |
| 9.10 | 1.10 |

```haskell
-- Version check
loadHieFile :: FilePath -> IO (Either HIEError HieFile)
loadHieFile path = do
  header <- readHieHeader path
  if hieVersion header == currentHieVersion
    then Right <$> readHieFile path
    else return $ Left $ VersionMismatch
           (hieVersion header)
           currentHieVersion
```

## Troubleshooting

### Missing HIE Files

```
Error: HIE file not found for module Api.Handler
  Expected: .hie/Api/Handler.hie

  Build with HIE generation:
    stack build --ghc-options="-fwrite-ide-info -hiedir=.hie"
```

### Version Mismatch

```
Error: HIE file version mismatch
  File: .hie/Api/Handler.hie
  Expected version: 1.10 (GHC 9.10)
  Found version: 1.9 (GHC 9.8)

  Rebuild with current GHC:
    stack clean && stack build
```

### Corrupt HIE Files

```bash
# Verify HIE files
argus index --verify .hie/

# Rebuild corrupt files
argus index --rebuild .hie/
```

## Next Steps

- **[Analysis Passes](./analysis-passes)**: Full analysis pipeline
- **[Fix System](./fix-system)**: How fixes use type info
- **[Working with HIE](../usage-guide/working-with-hie)**: User guide
