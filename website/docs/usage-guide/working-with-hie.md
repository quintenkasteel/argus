---
sidebar_position: 5
title: Working with HIE Files
description: Deep semantic analysis using GHC's HIE files
---

# Working with HIE Files

HIE (Haskell Interface Extended) files contain rich type information generated by GHC. Argus uses these files for deep semantic analysis in full mode.

## What are HIE Files?

HIE files are binary files generated by GHC that contain:

- **Full AST**: Complete syntax tree with source locations
- **Type information**: Types of all expressions
- **Name resolution**: Where identifiers are defined and used
- **Module dependencies**: Import/export relationships

This information enables analysis that's impossible with syntax alone.

## Generating HIE Files

### Stack Configuration

Add to your `stack.yaml`:

```yaml
ghc-options:
  "$locals":
    -fwrite-ide-info
    -hiedir=.hie
```

Or in `package.yaml`:

```yaml
ghc-options:
  - -fwrite-ide-info
  - -hiedir=.hie
```

### Building

```bash
# Clean build to ensure fresh HIE files
stack clean
stack build
```

### Verification

```bash
# Check HIE files exist
ls .hie/

# You should see files like:
# MyProject/
#   Types.hie
#   Core.hie
#   ...
```

## Using Full Mode

Once HIE files are generated:

```bash
argus check --mode full --hie-dir .hie src/
```

Or configure in `argus.toml`:

```toml
[general]
mode = "full"
hie-dir = ".hie"
```

## HIE-Enabled Features

### Type-Aware Unused Detection

Quick mode uses heuristics; full mode knows exactly what's used:

```haskell
module MyModule (processData) where

-- Quick mode: might miss that 'helper' is called from TH
-- Full mode: sees the actual call graph
helper :: Int -> Int
helper = (* 2)

processData :: Int -> Int
processData = helper . (+ 1)
```

### Wildcard Import Resolution

```haskell
import Data.Map (*)

-- Quick mode: can't determine which functions are used
-- Full mode: reports precisely which are unused

example = M.lookup "key" myMap
-- Full mode: "Only 'lookup' is used from Data.Map"
```

### Template Haskell Analysis

```haskell
{-# LANGUAGE TemplateHaskell #-}

import Data.Aeson.TH (deriveJSON, defaultOptions)

data User = User { userName :: Text, userAge :: Int }

$(deriveJSON defaultOptions ''User)

-- Full mode understands:
-- - parseJSON, toJSON are generated
-- - userName, userAge are used via TH
-- - These aren't actually unused
```

### Cross-Module Analysis

```haskell
-- In Module A
module A (helper) where
helper :: Int -> Int
helper = (* 2)

-- In Module B
module B where
import A (helper)

-- Full mode tracks:
-- - helper is exported from A
-- - helper is imported by B
-- - helper is used/unused in B
```

### Precise Type Information

```haskell
-- Full mode knows the exact type
let x = fromMaybe "" maybeName

-- Can apply type-specific rules:
-- "x has type String - consider Text for performance"
```

## Building the HIE Index

For large projects, build an index for faster queries:

```bash
argus index --hie-dir .hie --output .argus-index
```

Then use the index:

```bash
argus check --mode full --index .argus-index src/
```

## HIE File Management

### Keeping HIE Files Fresh

HIE files must match your source:

```bash
# After source changes
stack build

# Or use watch mode
stack build --file-watch
```

### Gitignore

Add to `.gitignore`:

```
.hie/
.argus-index/
```

### CI Caching

Cache HIE files for faster CI:

```yaml
# GitHub Actions
- uses: actions/cache@v4
  with:
    path: |
      .hie/
      .argus-index/
    key: hie-${{ hashFiles('**/*.hs') }}
```

## HIE Query Examples

### Finding All Usages

```bash
# Find all uses of a function
argus query --hie-dir .hie --find-uses "MyModule.myFunction"
```

### Type at Location

```bash
# Get type at specific location
argus query --hie-dir .hie --type-at "src/MyModule.hs:42:10"
```

### Module Dependencies

```bash
# Show what a module depends on
argus query --hie-dir .hie --deps "MyModule"
```

## Troubleshooting

### HIE Files Not Found

```
Error: No HIE files found in .hie/
```

**Solutions:**

1. Verify GHC options are set:
```bash
stack build --verbose 2>&1 | grep -i hie
```

2. Check the HIE directory matches:
```bash
# Should match your -hiedir option
ls .hie/
```

3. Rebuild:
```bash
stack clean && stack build
```

### Version Mismatch

```
Error: HIE file version mismatch
Expected: 9.10.3
Found: 9.8.1
```

**Solution:** Rebuild with the correct GHC version:

```bash
stack clean
stack build
```

### Incomplete HIE Data

```
Warning: Incomplete type information for MyModule
```

This can happen with:
- Compilation errors (module didn't fully compile)
- Template Haskell issues
- CPP conditionals

**Solution:** Fix compilation issues first:

```bash
stack build --fast  # Check for errors
stack build         # Full build with HIE
```

### Memory Issues

Large projects may need more memory:

```bash
stack build --ghc-options="+RTS -M8G -RTS"
```

### Stale HIE Files

If analysis seems wrong:

```bash
# Force rebuild
rm -rf .hie/
stack clean
stack build
```

## Performance Optimization

### Incremental Analysis

Only analyze changed modules:

```bash
# First run: build full index
argus index --hie-dir .hie

# Subsequent runs: incremental
argus check --mode full --incremental src/
```

### Parallel Processing

```bash
# Use multiple cores
argus check --mode full --jobs 4 src/
```

### Selective Full Mode

Use full mode only where needed:

```bash
# Quick mode for most code
argus check --mode quick src/

# Full mode for critical modules
argus check --mode full --hie-dir .hie src/Core/
```

## Integration with HLS

Argus can use HIE files generated by Haskell Language Server:

```bash
# HLS generates HIE files in .hie by default
# Argus can use these directly
argus check --mode full --hie-dir .hie src/
```

## HIE vs Quick Mode

| Aspect | Quick Mode | Full Mode (HIE) |
|--------|------------|-----------------|
| Setup | None | Requires build |
| Speed | ~1000 files/sec | Depends on HIE size |
| Types | No | Full |
| TH awareness | Heuristic | Complete |
| Cross-module | Limited | Full |
| Wildcard imports | Heuristic | Precise |
| Memory | Low | Higher |

## Best Practices

### 1. Development: Quick Mode

```bash
# Fast feedback while coding
argus check --mode quick src/
```

### 2. Pre-Commit: Full Mode

```bash
# Thorough check before committing
stack build
argus check --mode full src/
```

### 3. CI: Both Modes

```yaml
# Quick mode for fast feedback
quick-check:
  script: argus check --mode quick src/

# Full mode after build
full-check:
  needs: [build]
  script: argus check --mode full src/
```

### 4. Keep HIE Files Fresh

Always rebuild after source changes before running full mode.

## Next Steps

- **[Analysis Modes](./analysis-modes)**: Compare all three modes
- **[Architecture Analysis](../rules/architecture)**: Module dependency rules
- **[Unused Code Detection](../rules/overview#unused-code)**: Finding dead code
