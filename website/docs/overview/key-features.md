---
sidebar_position: 2
title: Key Features
description: Comprehensive overview of Argus's analysis capabilities
---

# Key Features

Argus provides a comprehensive suite of static analysis capabilities designed for enterprise Haskell development.

## Multi-Mode Analysis

### Quick Mode (Default)

Fast syntax-only analysis using GHC's parser. No compilation required.

```bash
argus check --mode quick src/
```

**Capabilities:**
- Naming convention checks
- Pattern matching (partial functions, anti-patterns)
- Import style analysis
- Basic unused import detection
- Pragma analysis
- Space leak pattern detection
- Security pattern matching

**Performance:** ~1,000 files/second on modern hardware

### Full Mode

Semantic analysis using HIE files generated by GHC. Requires prior compilation.

```bash
# First, compile with HIE output
stack build --ghc-options="-fwrite-ide-info -hiedir=.hie"

# Then analyze
argus check --mode full src/
```

**Additional Capabilities:**
- Type-aware unused code detection
- Template Haskell generated code analysis
- Precise wildcard import checking
- Cross-module dependency analysis
- Full architecture analysis with coupling metrics

### Plugin Mode

Compile-time analysis via GHC plugin for maximum precision.

```yaml
# In stack.yaml
ghc-options:
  "$locals": -fplugin=Argus.Plugin
```

**Additional Capabilities:**
- Core-to-Core analysis pass
- Strictness analysis
- Type-level rule enforcement

## Smart Unused Code Detection

Argus builds a complete dependency graph of your codebase to identify truly unused code.

### Template Haskell Awareness

Unlike simple unused-import checkers, Argus understands Template Haskell:

```haskell
-- Argus knows parseJSON is used by deriveJSON
data User = User { name :: Text, age :: Int }
$(deriveJSON defaultOptions ''User)
```

Configure TH-generated roots:

```toml
[unused]
th-roots = ["parseJSON", "toJSON", "makeLenses", "deriveJSON"]
```

### Entry Point Configuration

Define your application's entry points:

```toml
[unused]
roots = ["^Main.main$", "^Paths_.*", "^Spec\\."]
```

### Comprehensive Checks

- Unused functions and types
- Unused imports (with HIE-based wildcard resolution)
- Unused exports
- Unused constructors and record fields
- Unused local bindings
- Unused type class instances (optional)

## Security Analysis

### Injection Vulnerabilities

Detects SQL injection via string concatenation:

```haskell
-- Argus detects this pattern
query = "SELECT * FROM users WHERE id = '" ++ userId ++ "'"
```

Command injection through shell calls:

```haskell
-- Flagged: command injection risk
system $ "rm -rf " ++ userInput
```

### Cryptography Issues

- Weak algorithms (MD5, SHA1, DES, RC4)
- Hardcoded encryption keys
- Insecure random number generation

### Secrets Detection

- Hardcoded passwords and API keys
- Connection strings with credentials
- AWS/Azure/GCP credentials in source

### Unsafe Operations

- `unsafePerformIO`, `unsafeCoerce`, `unsafeDupablePerformIO`
- Unchecked FFI calls
- Missing null pointer checks in foreign imports

### Debug Code

Detects leftover debug statements:

```haskell
-- Error: debug code in production
result = trace "DEBUG: processing" $ processData input
```

## Performance Detection

### Data Structure Issues

- List used as map/set (O(n) lookups)
- `String` instead of `Text`/`ByteString`
- Repeated container lookups

### Algorithm Inefficiencies

```haskell
-- Warning: O(n) where O(1) is possible
isEmpty xs = length xs == 0

-- Suggestion: use null
isEmpty xs = null xs
```

### Lazy vs Strict Issues

```haskell
-- Warning: space leak potential
sumList = foldl (+) 0

-- Fixed: use strict fold
sumList = foldl' (+) 0
```

### Fusion Blockers

Patterns that prevent stream fusion and cause intermediate list materialization.

## Space Leak Detection

| Pattern | Issue | Detection |
|---------|-------|-----------|
| `foldl` | Lazy accumulator | Replace with `foldl'` |
| `Control.Monad.State` | Lazy state updates | Use `.Strict` variant |
| Non-strict record fields | Thunk accumulation | Add `!` or `StrictData` |
| `getContents` | Lazy IO | Use strict Text/ByteString IO |
| `hGetContents` | Lazy IO, resource leak | Use `Data.Text.IO.hGetContents` |
| Lazy accumulators | Thunk buildup | Use `seq`, `($!)`, or `BangPatterns` |

## Complexity Metrics

Track code complexity with configurable thresholds:

| Metric | Default Warning | Default Error | Description |
|--------|-----------------|---------------|-------------|
| Cyclomatic Complexity | 10 | 20 | Decision points |
| Cognitive Complexity | 15 | 25 | Understandability score |
| Function Line Count | 50 | - | Lines per function |
| Nesting Depth | 4 | - | Maximum indentation |
| Parameter Count | 5 | - | Function arguments |
| Pattern Branches | 10 | - | Case alternatives |

## Architecture Analysis

### Circular Dependency Detection

Finds import cycles up to configurable length:

```
Circular dependency detected:
  Module.A → Module.B → Module.C → Module.A
```

### Layer Violation Detection

Define architectural layers and enforce boundaries:

```toml
[[architecture.layers]]
name = "Core"
patterns = ["*.Types", "*.Core"]
can-import = ["Core"]

[[architecture.layers]]
name = "Data"
patterns = ["*.Data.*", "*.Model.*"]
can-import = ["Core", "Data"]

[[architecture.layers]]
name = "Service"
patterns = ["*.Service.*"]
can-import = ["Core", "Data", "Service"]

[[architecture.layers]]
name = "API"
patterns = ["*.API.*", "*.Handler.*"]
can-import = ["Core", "Data", "Service", "API"]
```

### Coupling Metrics

- **Afferent coupling (Ca)**: Modules depending on this module
- **Efferent coupling (Ce)**: Modules this module depends on
- **Instability**: Ce / (Ca + Ce)
- **Abstractness**: Abstract types / total types
- **Distance from main sequence**

### DOT Graph Export

Visualize your module dependencies:

```bash
argus architecture --output graph.dot src/
dot -Tsvg graph.dot -o dependencies.svg
```

## Safe Auto-Fix

### Conflict Detection

- Identifies overlapping edits
- Detects dependent fixes
- Finds semantic conflicts

### Topological Ordering

- Builds dependency graph of fixes
- Applies in safe order
- Handles cycles gracefully

### Transactional Semantics

- All-or-nothing application
- Automatic rollback on failure
- Backup file creation

### Validation Pipeline

- Re-parses after each fix
- Ensures syntactic correctness
- Catches semantic breaks

### Safety Levels

| Level | Meaning | Auto-Apply |
|-------|---------|------------|
| `safe` | Always safe | Yes |
| `mostly-safe` | Safe in most cases | With config |
| `needs-review` | Requires human review | No |
| `unsafe` | May change semantics | No |

## Output Formats

| Format | Use Case | Fixes Support |
|--------|----------|---------------|
| Terminal | Development | Display only |
| JSON | Custom tooling | Full support |
| SARIF | GitHub Code Scanning | Full support |
| HTML | Reports | Display only |
| JUnit | CI test frameworks | Display only |
| CodeClimate | Code Climate integration | Display only |
| Checkstyle | Legacy CI tools | Display only |
| Plain | Simple text output | Display only |

## IDE Integration

### LSP Server

Real-time diagnostics in your editor:

```bash
argus lsp
```

Supports:
- Diagnostics on save
- Code actions for fixes
- Hover information
- Go to definition
- Find references
- Document symbols

### Editor Support

- **VS Code**: Via Haskell extension or SARIF viewer
- **Neovim**: Native LSP configuration
- **Emacs**: Via lsp-mode
- **IntelliJ**: Via LSP plugin

## Next Steps

- **[Quickstart](./quickstart)**: Get running in 5 minutes
- **[Analysis Modes](../usage-guide/analysis-modes)**: Deep dive into each mode
- **[Rules Reference](../rules/overview)**: Explore all rule categories
