{-# LANGUAGE StrictData #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE PackageImports #-}

-- |
-- Module      : Argus.Analysis.Semantic
-- Description : Semantic analysis using HIE files and hiedb
-- Copyright   : (c) 2024
-- License     : MIT
--
-- This module provides semantic analysis capabilities using HIE
-- (Haskell Interface Extended) files generated by GHC. It uses the
-- hiedb library for indexing and querying HIE data, enabling:
--
-- * Type-aware analysis
-- * Cross-module reference tracking
-- * Finding definitions and usages
-- * Unused code detection at semantic level
module Argus.Analysis.Semantic
  ( -- * HIE Database
    HieDb
  , withHieDb
  , initHieDb
  , indexHieFiles
  , indexHieFilesWithErrors
  , IndexResult (..)

    -- * Queries
  , findDefinition
  , findReferences
  , findTypeReferences
  , getModuleInfo
  , getAllModules
  , getExports
  , getTypeClassMembers
  , getWildcardImportMembers

    -- * Semantic Diagnostics
  , SemanticDiagnostic (..)
  , DefinitionResult (..)
  , ReferenceResult (..)
  , ModuleInfo (..)
  , SymbolInfo (..)
  , runSemanticAnalysis
  , runFullSemanticAnalysis
  , findUnusedExports
  , findUnusedDefinitions
  , findTypeMismatches
  , findDeepImportChains
  , findSingleUseSymbols
  , getSymbolReferenceCount

    -- * HIE Data for unused detection
  , HieData (..)
  , hieImports
  , hieExports
  , loadHieFiles

    -- * Dependency Graph building
  , buildGraphFromHieDb

    -- * Re-exports for convenience
  , HieModuleRow (..)
  ) where

import Control.Exception (try, SomeException)
import Control.Monad (forM, when)
import System.IO (hPutStrLn, stderr)
import Data.Either (partitionEithers)
import Data.IORef (newIORef)
import Data.List (sortBy)
import Data.List.NonEmpty qualified as NE  -- needed for NE.head and NE.groupBy
import Data.Map.Strict qualified as Map
import Data.Maybe (mapMaybe, catMaybes, fromMaybe)
import Data.Ord (comparing)
import Data.Set qualified as Set
import Data.Text (Text)
import Data.Text qualified as T
import System.Directory (doesDirectoryExist, listDirectory, createDirectoryIfMissing)
import System.FilePath ((</>), takeExtension, takeDirectory, takeBaseName)

-- Use qualified imports from ghc package to avoid conflicts with ghc-lib-parser
import "ghc" GHC.Types.Name (occNameString)
import "ghc" GHC.Types.Name.Occurrence (mkOccName, varName, tcClsName)
import "ghc" GHC.Unit.Module (moduleNameString, mkModuleName, ModuleName)

-- Import from hiedb
import HieDb (HieDb, withHieDb, getAllIndexedMods, HieModuleRow(..), RefRow(..), DefRow(..), Res, (:.)(..))
import HieDb qualified
import HieDb.Types ( modInfoName, modInfoSrcFile, modInfoUnit, runDbM)
import HieDb.Utils (makeNc)

import Argus.Types (SrcSpan(..), Severity(..), QualifiedName(..), noSrcSpan, Symbol(..), SymbolKind(..), mkSrcSpanRaw)
import Argus.Analysis.DepGraph (DepGraph, buildGraph, EdgeKind(..))

--------------------------------------------------------------------------------
-- Database Initialization
--------------------------------------------------------------------------------

-- | Initialize a HieDb at the given path
-- Creates the database file and schema if it doesn't exist
initHieDb :: FilePath -> IO ()
initHieDb dbPath = do
  createDirectoryIfMissing True (takeDirectory dbPath)
  withHieDb dbPath $ \db -> do
    HieDb.initConn db

-- | Result of indexing HIE files
data IndexResult = IndexResult
  { irIndexed :: Int      -- ^ Number of successfully indexed files
  , irFailed  :: Int      -- ^ Number of files that failed to index
  , irErrors  :: [Text]   -- ^ Error messages for failed files
  , irVersionMismatch :: Bool  -- ^ Whether version mismatch was detected
  }
  deriving stock (Eq, Show)

-- | Index HIE files with proper error tracking
indexHieFiles :: FilePath -> FilePath -> IO Int
indexHieFiles dbPath hieDir = irIndexed <$> indexHieFilesWithErrors dbPath hieDir

-- | Index HIE files and return detailed results including errors
-- Detects GHC version mismatches and provides helpful error messages
indexHieFilesWithErrors :: FilePath -> FilePath -> IO IndexResult
indexHieFilesWithErrors dbPath hieDir = do
  hieFiles <- findHieFilesRecursive hieDir
  nc <- newIORef =<< makeNc
  withHieDb dbPath $ \db -> do
    HieDb.initConn db
    results <- forM hieFiles $ \hieFile -> do
      result <- try @SomeException $ runDbM nc $
        HieDb.addRefsFrom db (Just hieDir) HieDb.defaultSkipOptions hieFile
      case result of
        Left err -> pure $ Left (hieFile, T.pack $ show err)
        Right indexed -> pure $ Right (if indexed then 1 else 0)
    let (errors, successes) = partitionEithers results
        errorMsgs = map (\(f, e) -> T.pack f <> ": " <> formatHieError e) errors
        -- Detect version mismatch by looking for common error patterns
        hasVersionMismatch = any (isVersionMismatchError . snd) errors
    pure IndexResult
      { irIndexed = sum successes
      , irFailed = length errors
      , irErrors = errorMsgs
      , irVersionMismatch = hasVersionMismatch
      }

-- | Check if an error message indicates a HIE version mismatch
isVersionMismatchError :: Text -> Bool
isVersionMismatchError msg =
  any (`T.isInfixOf` T.toLower msg)
    [ "hie file version"
    , "version mismatch"
    , "ghc version"
    , "was created by ghc"
    , "hiefile"
    , "bad interface"
    ]

-- | Format HIE error messages with helpful guidance
formatHieError :: Text -> Text
formatHieError msg
  | isVersionMismatchError msg =
      msg <> "\n  Hint: HIE files were generated by a different GHC version.\n" <>
      "  Rebuild your project with the same GHC version used by argus,\n" <>
      "  or rebuild argus with the same GHC version as your project."
  | otherwise = msg

-- | Find all .hie files recursively in a directory
findHieFilesRecursive :: FilePath -> IO [FilePath]
findHieFilesRecursive dir = do
  exists <- doesDirectoryExist dir
  if not exists
    then pure []
    else do
      entries <- listDirectory dir
      concat <$> forM entries (\entry -> do
        let path = dir </> entry
        isDir <- doesDirectoryExist path
        if isDir
          then findHieFilesRecursive path
          else pure [path | takeExtension path == ".hie"])

--------------------------------------------------------------------------------
-- Query Functions
--------------------------------------------------------------------------------

-- | Find the definition of a symbol by name
findDefinition :: HieDb -> Text -> Maybe Text -> IO [DefinitionResult]
findDefinition db name mModule = do
  let occName = mkOccName varName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findDef db occName modName Nothing
  pure $ mapMaybe toDefinitionResult results

-- | Result of a definition lookup
data DefinitionResult = DefinitionResult
  { defResultFile :: FilePath
  , defResultModule :: Text
  , defResultName :: Text
  , defResultSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

toDefinitionResult :: Res DefRow -> Maybe DefinitionResult
toDefinitionResult (row :. modInfo) = Just DefinitionResult
  { defResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , defResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , defResultName = T.pack $ occNameString $ defNameOcc row
  , defResultSpan = mkSrcSpanRaw
      (fromMaybe "" (modInfoSrcFile modInfo))
      (defSLine row)
      (defSCol row)
      (defELine row)
      (defECol row)
  }

-- | Find all references to a symbol
findReferences :: HieDb -> Text -> Maybe Text -> IO [ReferenceResult]
findReferences db name mModule = do
  let occName = mkOccName varName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findReferences db False occName modName Nothing []
  pure $ mapMaybe toReferenceResult results

-- | Result of a reference lookup
data ReferenceResult = ReferenceResult
  { refResultFile :: FilePath
  , refResultModule :: Text
  , refResultSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

toReferenceResult :: Res RefRow -> Maybe ReferenceResult
toReferenceResult (row :. modInfo) = Just ReferenceResult
  { refResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , refResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , refResultSpan = mkSrcSpanRaw
      (fromMaybe "" (modInfoSrcFile modInfo))
      (refSLine row)
      (refSCol row)
      (refELine row)
      (refECol row)
  }

-- | Find type references
findTypeReferences :: HieDb -> Text -> Maybe Text -> IO [ReferenceResult]
findTypeReferences db name mModule = do
  let occName = mkOccName tcClsName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findTypeRefs db False occName modName Nothing []
  pure $ mapMaybe toTypeRefResult results

toTypeRefResult :: Res HieDb.TypeRef -> Maybe ReferenceResult
toTypeRefResult (row :. modInfo) = Just ReferenceResult
  { refResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , refResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , refResultSpan = mkSrcSpanRaw
      (fromMaybe "" (modInfoSrcFile modInfo))
      (HieDb.typeRefSLine row)
      (HieDb.typeRefSCol row)
      (HieDb.typeRefELine row)
      (HieDb.typeRefECol row)
  }

-- | Get information about a module
getModuleInfo :: HieDb -> Text -> IO (Maybe ModuleInfo)
getModuleInfo db modNameText = do
  let mn = mkModuleName (T.unpack modNameText)
  result <- HieDb.resolveUnitId db mn
  case result of
    Left _ -> pure Nothing
    Right unit -> do
      mRow <- HieDb.lookupHieFile db mn unit
      pure $ fmap toModuleInfo mRow

-- | Module information
data ModuleInfo = ModuleInfo
  { moduleInfoName :: Text
  , moduleInfoFile :: Maybe FilePath
  , moduleInfoHieFile :: FilePath
  }
  deriving stock (Eq, Show)

toModuleInfo :: HieModuleRow -> ModuleInfo
toModuleInfo row = ModuleInfo
  { moduleInfoName = T.pack $ moduleNameString $ modInfoName $ hieModInfo row
  , moduleInfoFile = modInfoSrcFile $ hieModInfo row
  , moduleInfoHieFile = hieModuleHieFile row
  }

-- | Get all indexed modules
getAllModules :: HieDb -> IO [ModuleInfo]
getAllModules db = do
  rows <- getAllIndexedMods db
  pure $ map toModuleInfo rows

-- | Get exports of a module
getExports :: HieDb -> Text -> IO [Text]
getExports db modNameText = do
  let mn = mkModuleName (T.unpack modNameText)
  exports <- HieDb.getExportsForModule db mn
  pure $ map (T.pack . occNameString . HieDb.exportName) exports

-- | Get all members of a type class or data type by looking at the exportParent field
-- This is used for resolving wildcard imports like `ToJSON (..)`
-- When you import `Data.Aeson (ToJSON (..))`, this function returns ["toJSON", "toEncoding", ...]
getTypeClassMembers :: HieDb -> Text -> Text -> IO [Text]
getTypeClassMembers db modNameText className = do
  let mn = mkModuleName (T.unpack modNameText)
  exports <- HieDb.getExportsForModule db mn
  -- Filter exports where the parent matches the class name
  let members = filter hasMatchingParent exports
  pure $ map (T.pack . occNameString . HieDb.exportName) members
  where
    hasMatchingParent export = case HieDb.exportParent export of
      Just parentOcc -> occNameString parentOcc == T.unpack className
      Nothing -> False

-- | Resolve what a wildcard import brings in
-- Given a module name and a type/class name imported with (..), returns all members
-- Example: getWildcardImportMembers db "Data.Aeson" "ToJSON" returns ["toJSON", "toEncoding", ...]
getWildcardImportMembers :: HieDb -> Text -> Text -> IO [Text]
getWildcardImportMembers db modName typeName = do
  -- First, try to get members directly from the module
  members <- getTypeClassMembers db modName typeName

  if not (null members)
    then pure members
    else do
      -- If no members found, the type might be re-exported from another module
      -- Find where the type is originally defined
      defs <- findDefinition db typeName (Just modName)
      case defs of
        [] -> pure []  -- No definition found
        (defResult:_) -> getTypeClassMembers db (defResultModule defResult) typeName

--------------------------------------------------------------------------------
-- Symbol Information
--------------------------------------------------------------------------------

-- | Symbol information
data SymbolInfo = SymbolInfo
  { symbolInfoName :: Text
  , symbolInfoKind :: Text
  , symbolInfoSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

--------------------------------------------------------------------------------
-- Semantic Diagnostics
--------------------------------------------------------------------------------

-- | A semantic diagnostic from HIE analysis
data SemanticDiagnostic = SemanticDiagnostic
  { semDiagFile :: FilePath
  , semDiagSpan :: SrcSpan
  , semDiagMessage :: Text
  , semDiagSeverity :: Severity
  , semDiagCode :: Text
  }
  deriving stock (Eq, Show)

-- | Run semantic analysis on the indexed codebase
runSemanticAnalysis :: HieDb -> IO [SemanticDiagnostic]
runSemanticAnalysis db = do
  unusedExports <- findUnusedExports db
  unusedDefs <- findUnusedDefinitions db
  pure $ unusedExports ++ unusedDefs

-- | Find exports that are not used anywhere else in the codebase
findUnusedExports :: HieDb -> IO [SemanticDiagnostic]
findUnusedExports db = do
  mods <- getAllIndexedMods db
  concat <$> forM mods (\modRow -> do
    let mn = modInfoName $ hieModInfo modRow
        srcFile = modInfoSrcFile $ hieModInfo modRow
    exports <- HieDb.getExportsForModule db mn

    -- For each export, check if it's referenced anywhere
    unusedList <- forM exports $ \export -> do
      let occName = HieDb.exportName export
          exportMod = HieDb.exportMod export
      refs <- HieDb.findReferences db False occName (Just exportMod) Nothing []

      -- If no external references, it might be unused
      let externalRefs = filter (\(_ :. m) -> modInfoName m /= mn) refs
      if null externalRefs
        then pure $ Just SemanticDiagnostic
          { semDiagFile = fromMaybe "" srcFile
          , semDiagSpan = mkSrcSpanRaw (fromMaybe "" srcFile) 1 1 1 1
          , semDiagMessage = "Export '" <> T.pack (occNameString occName) <> "' has no external references"
          , semDiagSeverity = Warning
          , semDiagCode = "semantic/unused-export"
          }
        else pure Nothing

    pure $ catMaybes unusedList)

-- | Find definitions that are not referenced anywhere
-- Note: This uses searchDef which searches globally, then filters by module.
-- For large codebases, this may need optimization.
findUnusedDefinitions :: HieDb -> IO [SemanticDiagnostic]
findUnusedDefinitions db = do
  -- Search for all definitions using a wildcard pattern
  -- searchDef with empty string matches "_:%" which gets all definitions
  allDefs <- HieDb.searchDef db ""

  -- Group by module and check references
  concat <$> forM allDefs (\(defRow :. modInfo) -> do
    let occName = defNameOcc defRow
        mn = modInfoName modInfo
        unit = modInfoUnit modInfo

    -- Find all references to this definition
    refs <- HieDb.findReferences db False occName (Just mn) (Just unit) []

    -- Filter out self-references (definition site)
    let nonSelfRefs = filter (isNotSelfRef defRow) refs

    if null nonSelfRefs
      then pure [SemanticDiagnostic
        { semDiagFile = fromMaybe "" (modInfoSrcFile modInfo)
        , semDiagSpan = mkSrcSpanRaw
            (fromMaybe "" (modInfoSrcFile modInfo))
            (defSLine defRow)
            (defSCol defRow)
            (defELine defRow)
            (defECol defRow)
        , semDiagMessage = "Definition '" <> T.pack (occNameString occName) <> "' is never used"
        , semDiagSeverity = Warning
        , semDiagCode = "semantic/unused-definition"
        }]
      else pure [])

isNotSelfRef :: DefRow -> Res RefRow -> Bool
isNotSelfRef defRow (refRow :. _) =
  not (defSLine defRow == refSLine refRow && defSCol defRow == refSCol refRow)

--------------------------------------------------------------------------------
-- HIE Data for Unused Detection
--------------------------------------------------------------------------------

-- | HIE data for a file, used by unused detection
-- This is a lightweight representation for the Unused module
data HieData = HieData
  { hieFile    :: FilePath
  , hieModule  :: Text
  , _hieImports :: [QualifiedName]
  , _hieExports :: [QualifiedName]
  }
  deriving stock (Eq, Show)

-- | Get imports from HIE data
hieImports :: HieData -> [QualifiedName]
hieImports = _hieImports

-- | Get exports from HIE data
hieExports :: HieData -> [QualifiedName]
hieExports = _hieExports

-- | Load HIE data from a directory
-- This fully indexes HIE files and extracts module information including
-- imports and exports for semantic analysis.
-- Reports warnings to stderr if HIE file version mismatches are detected.
loadHieFiles :: FilePath -> IO [HieData]
loadHieFiles hieDir = do
  -- Check if directory exists
  exists <- doesDirectoryExist hieDir
  if not exists
    then pure []
    else do
      -- Create a database in the HIE directory for caching
      let dbPath = hieDir </> ".hiedb"

      -- Initialize and index HIE files with error tracking
      initHieDb dbPath
      indexResult <- indexHieFilesWithErrors dbPath hieDir

      -- Report any errors to stderr (especially version mismatches)
      when (irFailed indexResult > 0) $ do
        hPutStrLn stderr $ "Warning: Failed to index " ++ show (irFailed indexResult) ++ " HIE file(s)"
        when (irVersionMismatch indexResult) $
          hPutStrLn stderr $ "  This may be due to a GHC version mismatch.\n" ++
                            "  Rebuild your project with: stack clean && stack build\n" ++
                            "  Or ensure your project uses the same GHC version as argus."

      -- Query all modules and build HieData
      withHieDb dbPath $ \db -> do
        modRows <- getAllIndexedMods db
        forM modRows $ \modRow -> do
          let modInfo = hieModInfo modRow
              modName = modInfoName modInfo
              modNameText = T.pack $ moduleNameString modName
              -- Use source file if available, otherwise derive from HIE file path
              srcFile = case modInfoSrcFile modInfo of
                Just f -> f
                Nothing -> deriveSrcFromHie (hieModuleHieFile modRow)

          -- Get exports for this module
          exports <- HieDb.getExportsForModule db modName
          let exportNames = map exportToQualifiedName exports

          -- Get imports by finding all external references from this module
          -- We look at what modules are referenced by definitions in this module
          imports <- getModuleImports db modRow

          pure HieData
            { hieFile = srcFile
            , hieModule = modNameText
            , _hieImports = imports
            , _hieExports = exportNames
            }
  where
    -- Derive source file from HIE file path (e.g., ".hie/Main.hie" -> "src/Main.hs")
    -- This is a fallback when modInfoSrcFile is not available
    deriveSrcFromHie :: FilePath -> FilePath
    deriveSrcFromHie hiePath =
      let baseName = takeBaseName hiePath  -- "Main" from ".hie/Main.hie"
      in "src/" ++ baseName ++ ".hs"  -- Assume src directory

-- | Convert a HieDb export to a QualifiedName
exportToQualifiedName :: HieDb.ExportRow -> QualifiedName
exportToQualifiedName export = QualifiedName
  { qnModule = Just $ T.pack $ moduleNameString $ HieDb.exportMod export
  , qnName = T.pack $ occNameString $ HieDb.exportName export
  }

-- | Get all imports for a module by analyzing its references
-- This finds all external modules that are referenced from the given module
getModuleImports :: HieDb -> HieModuleRow -> IO [QualifiedName]
getModuleImports db modRow = do
  let modInfo = hieModInfo modRow
      modName = modInfoName modInfo

  -- Get all definitions in this module
  allDefs <- HieDb.searchDef db ""

  -- Filter to definitions from this module
  let myDefs = filter (\(_ :. mi) -> modInfoName mi == modName) allDefs

  -- For each definition, find what it references from other modules
  importSets <- forM myDefs $ \(defRow :. _) -> do
    let occName = defNameOcc defRow
    refs <- HieDb.findReferences db False occName (Just modName) Nothing []

    -- Find references that come from OTHER modules
    let externalRefs = filter (\(_ :. mi) -> modInfoName mi /= modName) refs
        importedModules = map (\(_ :. mi) -> QualifiedName
          { qnModule = Just $ T.pack $ moduleNameString $ modInfoName mi
          , qnName = T.pack $ moduleNameString $ modInfoName mi
          }) externalRefs

    pure importedModules

  -- Deduplicate imports
  let allImports = concat importSets
      uniqueImports = nubByModule allImports

  pure uniqueImports
  where
    -- Using NonEmpty.groupBy guarantees non-empty groups
    nubByModule = map NE.head . NE.groupBy sameModule . sortBy (comparing qnModule)
    sameModule a b = qnModule a == qnModule b

--------------------------------------------------------------------------------
-- Advanced Semantic Analysis
--------------------------------------------------------------------------------

-- | Find symbols with mismatched types (different definitions with same name)
findTypeMismatches :: HieDb -> IO [SemanticDiagnostic]
findTypeMismatches db = do
  allDefs <- HieDb.searchDef db ""
  -- Group by name
  let grouped = groupByName allDefs
      mismatches = filter (\xs -> length xs > 1) grouped
  concat <$> forM mismatches checkMismatch
  where
    groupByName defs =
      let sorted = sortBy (comparing (\(d :. _) -> occNameString (defNameOcc d))) defs
      in groupBy' (\(d1 :. _) (d2 :. _) -> occNameString (defNameOcc d1) == occNameString (defNameOcc d2)) sorted

    -- Custom groupBy' that returns [[a]]
    groupBy' _ [] = []
    groupBy' eq (x:xs) =
      let (same, rest) = span (eq x) xs
      in (x:same) : groupBy' eq rest

    checkMismatch defs = pure $ mapMaybe toMismatchDiag defs

    toMismatchDiag (defRow :. modInfo) = Just SemanticDiagnostic
      { semDiagFile = fromMaybe "" (modInfoSrcFile modInfo)
      , semDiagSpan = mkSrcSpanRaw
          (fromMaybe "" (modInfoSrcFile modInfo))
          (defSLine defRow)
          (defSCol defRow)
          (defELine defRow)
          (defECol defRow)
      , semDiagMessage = "Symbol '" <> T.pack (occNameString (defNameOcc defRow)) <> "' is defined in multiple modules"
      , semDiagSeverity = Info
      , semDiagCode = "semantic/duplicate-definition"
      }

-- | Find unusually deep import chains
findDeepImportChains :: HieDb -> Int -> IO [SemanticDiagnostic]
findDeepImportChains db maxDepth = do
  mods <- getAllIndexedMods db
  chains <- forM mods $ \modRow -> do
    depth <- calculateImportDepth db (modInfoName $ hieModInfo modRow) 0 []
    if depth > maxDepth
      then pure $ Just SemanticDiagnostic
        { semDiagFile = fromMaybe "" (modInfoSrcFile $ hieModInfo modRow)
        , semDiagSpan = mkSrcSpanRaw (fromMaybe "" (modInfoSrcFile $ hieModInfo modRow)) 1 1 1 1
        , semDiagMessage = "Module has deep import chain (depth: " <> T.pack (show depth) <> ")"
        , semDiagSeverity = Warning
        , semDiagCode = "semantic/deep-import-chain"
        }
      else pure Nothing
  pure $ catMaybes chains

-- | Calculate import depth for a module
calculateImportDepth :: HieDb -> ModuleName -> Int -> [Text] -> IO Int
calculateImportDepth _ _ depth _ | depth > 20 = pure depth  -- Prevent infinite recursion
calculateImportDepth db modName currentDepth visited = do
  let modNameText = T.pack $ moduleNameString modName
  if modNameText `elem` visited
    then pure currentDepth  -- Cycle detected
    else do
      -- Get exports to find what this module depends on
      exports <- HieDb.getExportsForModule db modName
      let importedMods = map (HieDb.exportMod) exports
          uniqueMods = nub $ filter (/= modName) importedMods
      if null uniqueMods
        then pure currentDepth
        else do
          depths <- forM uniqueMods $ \m ->
            calculateImportDepth db m (currentDepth + 1) (modNameText : visited)
          pure $ maximum depths
  where
    nub = map NE.head . NE.groupBy (==) . NE.fromList . sortBy compare

-- | Comprehensive semantic analysis
runFullSemanticAnalysis :: HieDb -> IO [SemanticDiagnostic]
runFullSemanticAnalysis db = do
  unusedExports <- findUnusedExports db
  unusedDefs <- findUnusedDefinitions db
  typeMismatches <- findTypeMismatches db
  deepChains <- findDeepImportChains db 10
  pure $ unusedExports ++ unusedDefs ++ typeMismatches ++ deepChains

-- | Get reference count for a symbol
getSymbolReferenceCount :: HieDb -> Text -> Maybe Text -> IO Int
getSymbolReferenceCount db name mModule = do
  refs <- findReferences db name mModule
  pure $ length refs

-- | Find symbols that are referenced only once (potential code smell)
findSingleUseSymbols :: HieDb -> IO [SemanticDiagnostic]
findSingleUseSymbols db = do
  allDefs <- HieDb.searchDef db ""
  singleUse <- forM allDefs $ \(defRow :. modInfo) -> do
    let occName = defNameOcc defRow
        mn = modInfoName modInfo
    refs <- HieDb.findReferences db False occName (Just mn) Nothing []
    let nonSelfRefs = filter (isNotSelfRef defRow) refs
    if length nonSelfRefs == 1
      then pure $ Just SemanticDiagnostic
        { semDiagFile = fromMaybe "" (modInfoSrcFile modInfo)
        , semDiagSpan = mkSrcSpanRaw
            (fromMaybe "" (modInfoSrcFile modInfo))
            (defSLine defRow)
            (defSCol defRow)
            (defELine defRow)
            (defECol defRow)
        , semDiagMessage = "Symbol '" <> T.pack (occNameString occName) <> "' is used only once - consider inlining"
        , semDiagSeverity = Info
        , semDiagCode = "semantic/single-use"
        }
      else pure Nothing
  pure $ catMaybes singleUse

--------------------------------------------------------------------------------
-- Dependency Graph Building
--------------------------------------------------------------------------------

-- | Build a dependency graph from a HieDb database
-- Extracts all definitions, their references, and exports to build
-- a complete dependency graph for unused code detection
buildGraphFromHieDb :: FilePath -> IO DepGraph
buildGraphFromHieDb hieDir = do
  let dbPath = hieDir </> ".hiedb"
  exists <- doesDirectoryExist hieDir
  if not exists
    then pure $ buildGraph [] [] mempty
    else withHieDb dbPath $ \db -> do
      -- First ensure the database is initialized and indexed
      HieDb.initConn db

      -- Get all indexed modules
      mods <- getAllIndexedMods db

      -- Build a map from module name to source file
      -- This uses hieModuleHieFile as fallback when modInfoSrcFile is Nothing
      let modToFile = buildModToFileMap mods

      -- Get all definitions
      allDefs <- HieDb.searchDef db ""

      -- Build a map from (file, startLine, endLine) to qualified name
      -- for finding which definition contains a reference
      let defMap = buildDefMap modToFile allDefs

      -- Build symbols from definitions using the modToFile map
      let symbols = map (mkSymbolWithFallback modToFile) allDefs

      -- For each definition, find its references and create edges
      -- Edge goes from referencer -> referenced (A uses B => edge A -> B)
      edges <- buildAllEdges db allDefs defMap modToFile

      -- DON'T mark all exports as roots - that would make them all "used"
      -- Instead, let detectUnused.findRoots determine roots based on config patterns
      -- (e.g., ^Main.main$, Paths_.*, Template Haskell roots)
      pure $ buildGraph symbols edges mempty

-- | Build a map from module name to source file path
buildModToFileMap :: [HieModuleRow] -> Map.Map String FilePath
buildModToFileMap mods = Map.fromList
  [ (moduleNameString (modInfoName (hieModInfo m)), srcFile)
  | m <- mods
  , let srcFile = case modInfoSrcFile (hieModInfo m) of
          Just f -> f
          Nothing -> deriveSrcFromHie (hieModuleHieFile m)
  ]
  where
    deriveSrcFromHie hiePath =
      let baseName = takeBaseName hiePath
      in "src/" ++ baseName ++ ".hs"

-- | Build a map from (filePath, startLine, endLine) to QualifiedName
-- Used to find which definition contains a given reference location
buildDefMap :: Map.Map String FilePath -> [DefRow :. HieDb.ModuleInfo] -> Map.Map (FilePath, Int, Int) QualifiedName
buildDefMap modToFile defs = Map.fromList
  [ ((srcFile, defSLine defRow, defELine defRow), qualName)
  | (defRow :. modInfo) <- defs
  , let modNameStr = moduleNameString $ modInfoName modInfo
        modNameText = T.pack modNameStr
        qualName = QualifiedName
          { qnModule = Just modNameText
          , qnName = T.pack $ occNameString $ defNameOcc defRow
          }
        -- Use modToFile map with fallback
        srcFile = Map.findWithDefault "" modNameStr modToFile
  ]

-- | Find which definition contains a given source location
-- Since HieDb only stores the span of the name binding (not the full function body),
-- we find the definition whose start line is closest to (but not greater than) the reference line.
-- This works because Haskell top-level definitions are typically contiguous.
findContainingDef :: Map.Map (FilePath, Int, Int) QualifiedName -> FilePath -> Int -> Maybe QualifiedName
findContainingDef defMap file line =
  -- Find all definitions in this file whose start line is <= reference line
  let candidates = [ (qn, start)
                   | ((f, start, _end), qn) <- Map.toList defMap
                   , f == file
                   , start <= line
                   ]
  in case candidates of
    [] -> Nothing
    -- Return the definition with the largest start line (closest to reference)
    xs -> Just $ fst $ maximumBy (comparing snd) xs
  where
    maximumBy :: (a -> a -> Ordering) -> [a] -> a
    maximumBy cmp = foldr1 (\x y -> if cmp x y == GT then x else y)

-- | Build all edges by finding references for each definition
buildAllEdges :: HieDb -> [DefRow :. HieDb.ModuleInfo] -> Map.Map (FilePath, Int, Int) QualifiedName
              -> Map.Map String FilePath -> IO [(Symbol, Symbol, EdgeKind, SrcSpan)]
buildAllEdges db allDefs defMap modToFile = do
  edgeLists <- forM allDefs $ \(defRow :. modInfo) -> do
    let targetName = QualifiedName
          { qnModule = Just $ T.pack $ moduleNameString $ modInfoName modInfo
          , qnName = T.pack $ occNameString $ defNameOcc defRow
          }
        targetSymbol = Symbol
          { symbolName = targetName
          , symbolKind = Function
          , symbolSpan = noSrcSpan
          , symbolExported = True
          , symbolType = Nothing
          }

    -- Find all references to this definition
    refs <- HieDb.findReferences db False (defNameOcc defRow) (Just $ modInfoName modInfo) Nothing []

    -- For each reference, find the containing definition and create an edge
    let edges = catMaybes
          [ do  -- Maybe monad
              let refModName = moduleNameString $ modInfoName refModInfo
                  -- Use modToFile map for file path lookup
                  refFile = Map.findWithDefault "" refModName modToFile
                  refLine = refSLine refRow
              sourceName <- findContainingDef defMap refFile refLine
              -- Skip self-references
              if sourceName == targetName
                then Nothing
                else Just (mkSourceSymbol sourceName, targetSymbol, DirectReference, mkRefSpan refModName refRow)
          | (refRow :. refModInfo) <- refs
          ]

    pure edges

  pure $ concat edgeLists
  where
    mkSourceSymbol name = Symbol
      { symbolName = name
      , symbolKind = Function
      , symbolSpan = noSrcSpan
      , symbolExported = True
      , symbolType = Nothing
      }

    mkRefSpan modName refRow = mkSrcSpanRaw
      (Map.findWithDefault "" modName modToFile)
      (refSLine refRow)
      (refSCol refRow)
      (refELine refRow)
      (refECol refRow)

-- | Find all exported symbols across all modules
-- Note: Currently unused but kept for potential future semantic analysis features
_findAllExportedSymbols :: HieDb -> IO (Set.Set QualifiedName)
_findAllExportedSymbols db = do
  mods <- getAllIndexedMods db
  exportLists <- forM mods $ \modRow -> do
    let modName = modInfoName $ hieModInfo modRow
    exports <- HieDb.getExportsForModule db modName
    pure $ map (exportToQName modName) exports
  pure $ Set.fromList $ concat exportLists
  where
    exportToQName modName export = QualifiedName
      { qnModule = Just $ T.pack $ moduleNameString modName
      , qnName = T.pack $ occNameString $ HieDb.exportName export
      }

-- | Create a symbol with source file fallback from modToFile map
mkSymbolWithFallback :: Map.Map String FilePath -> (DefRow :. HieDb.ModuleInfo) -> Symbol
mkSymbolWithFallback modToFile (defRow :. modInfo) =
  let modNameStr = moduleNameString $ modInfoName modInfo
      modNameText = T.pack modNameStr
      symName = QualifiedName
        { qnModule = Just modNameText
        , qnName = T.pack $ occNameString $ defNameOcc defRow
        }
      -- Use modToFile map with fallback
      srcFile = Map.findWithDefault "" modNameStr modToFile
      defSpan = mkSrcSpanRaw
        srcFile
        (defSLine defRow)
        (defSCol defRow)
        (defELine defRow)
        (defECol defRow)
  in Symbol
    { symbolName = symName
    , symbolKind = Function  -- Simplified
    , symbolSpan = defSpan
    , symbolExported = True
    , symbolType = Nothing
    }

