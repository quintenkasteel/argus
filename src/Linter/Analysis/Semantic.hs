{-# LANGUAGE StrictData #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE PackageImports #-}

-- |
-- Module      : Linter.Analysis.Semantic
-- Description : Semantic analysis using HIE files and hiedb
-- Copyright   : (c) 2024
-- License     : MIT
--
-- This module provides semantic analysis capabilities using HIE
-- (Haskell Interface Extended) files generated by GHC. It uses the
-- hiedb library for indexing and querying HIE data, enabling:
--
-- * Type-aware analysis
-- * Cross-module reference tracking
-- * Finding definitions and usages
-- * Unused code detection at semantic level
module Linter.Analysis.Semantic
  ( -- * HIE Database
    HieDb
  , withHieDb
  , initHieDb
  , indexHieFiles

    -- * Queries
  , findDefinition
  , findReferences
  , findTypeReferences
  , getModuleInfo
  , getAllModules
  , getExports

    -- * Semantic Diagnostics
  , SemanticDiagnostic (..)
  , DefinitionResult (..)
  , ReferenceResult (..)
  , ModuleInfo (..)
  , SymbolInfo (..)
  , runSemanticAnalysis
  , findUnusedExports
  , findUnusedDefinitions

    -- * HIE Data for unused detection
  , HieData (..)
  , hieImports
  , hieExports
  , loadHieFiles

    -- * Re-exports for convenience
  , HieModuleRow (..)
  ) where

import Control.Exception (try, SomeException)
import Control.Monad (forM)
import Data.IORef (newIORef)
import Data.Maybe (mapMaybe, catMaybes, fromMaybe)
import Data.Text (Text)
import Data.Text qualified as T
import System.Directory (doesDirectoryExist, listDirectory, createDirectoryIfMissing)
import System.FilePath ((</>), takeExtension, takeDirectory)

-- Use qualified imports from ghc package to avoid conflicts with ghc-lib-parser
import "ghc" GHC.Types.Name (occNameString)
import "ghc" GHC.Types.Name.Occurrence (mkOccName, varName, tcClsName)
import "ghc" GHC.Unit.Module (moduleNameString, mkModuleName)

-- Import from hiedb
import HieDb (HieDb, withHieDb, getAllIndexedMods, HieModuleRow(..), RefRow(..), DefRow(..), Res(..), (:.)(..))
import HieDb qualified
import HieDb.Types (hieModuleHieFile, hieModInfo, modInfoName, modInfoSrcFile, modInfoUnit, runDbM)
import HieDb.Utils (makeNc)

import Linter.Types (SrcSpan(..), Severity(..), QualifiedName)

--------------------------------------------------------------------------------
-- Database Initialization
--------------------------------------------------------------------------------

-- | Initialize a HieDb at the given path
-- Creates the database file and schema if it doesn't exist
initHieDb :: FilePath -> IO ()
initHieDb dbPath = do
  createDirectoryIfMissing True (takeDirectory dbPath)
  withHieDb dbPath $ \db -> do
    HieDb.initConn db

-- | Index all HIE files in a directory into the database
-- Returns the number of files indexed
indexHieFiles :: FilePath -> FilePath -> IO Int
indexHieFiles dbPath hieDir = do
  hieFiles <- findHieFilesRecursive hieDir
  nc <- newIORef =<< makeNc
  withHieDb dbPath $ \db -> do
    HieDb.initConn db
    count <- forM hieFiles $ \hieFile -> do
      result <- try @SomeException $ runDbM nc $
        HieDb.addRefsFrom db (Just hieDir) HieDb.defaultSkipOptions hieFile
      case result of
        Left _ -> pure 0
        Right indexed -> pure (if indexed then 1 else 0)
    pure $ sum count

-- | Find all .hie files recursively in a directory
findHieFilesRecursive :: FilePath -> IO [FilePath]
findHieFilesRecursive dir = do
  exists <- doesDirectoryExist dir
  if not exists
    then pure []
    else do
      entries <- listDirectory dir
      concat <$> forM entries (\entry -> do
        let path = dir </> entry
        isDir <- doesDirectoryExist path
        if isDir
          then findHieFilesRecursive path
          else pure [path | takeExtension path == ".hie"])

--------------------------------------------------------------------------------
-- Query Functions
--------------------------------------------------------------------------------

-- | Find the definition of a symbol by name
findDefinition :: HieDb -> Text -> Maybe Text -> IO [DefinitionResult]
findDefinition db name mModule = do
  let occName = mkOccName varName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findDef db occName modName Nothing
  pure $ mapMaybe toDefinitionResult results

-- | Result of a definition lookup
data DefinitionResult = DefinitionResult
  { defResultFile :: FilePath
  , defResultModule :: Text
  , defResultName :: Text
  , defResultSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

toDefinitionResult :: Res DefRow -> Maybe DefinitionResult
toDefinitionResult (row :. modInfo) = Just DefinitionResult
  { defResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , defResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , defResultName = T.pack $ occNameString $ defNameOcc row
  , defResultSpan = SrcSpan
      { srcSpanFile = fromMaybe "" (modInfoSrcFile modInfo)
      , srcSpanStartLine = defSLine row
      , srcSpanStartCol = defSCol row
      , srcSpanEndLine = defELine row
      , srcSpanEndCol = defECol row
      }
  }

-- | Find all references to a symbol
findReferences :: HieDb -> Text -> Maybe Text -> IO [ReferenceResult]
findReferences db name mModule = do
  let occName = mkOccName varName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findReferences db False occName modName Nothing []
  pure $ mapMaybe toReferenceResult results

-- | Result of a reference lookup
data ReferenceResult = ReferenceResult
  { refResultFile :: FilePath
  , refResultModule :: Text
  , refResultSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

toReferenceResult :: Res RefRow -> Maybe ReferenceResult
toReferenceResult (row :. modInfo) = Just ReferenceResult
  { refResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , refResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , refResultSpan = SrcSpan
      { srcSpanFile = fromMaybe "" (modInfoSrcFile modInfo)
      , srcSpanStartLine = refSLine row
      , srcSpanStartCol = refSCol row
      , srcSpanEndLine = refELine row
      , srcSpanEndCol = refECol row
      }
  }

-- | Find type references
findTypeReferences :: HieDb -> Text -> Maybe Text -> IO [ReferenceResult]
findTypeReferences db name mModule = do
  let occName = mkOccName tcClsName (T.unpack name)
      modName = fmap (mkModuleName . T.unpack) mModule
  results <- HieDb.findTypeRefs db False occName modName Nothing []
  pure $ mapMaybe toTypeRefResult results

toTypeRefResult :: Res HieDb.TypeRef -> Maybe ReferenceResult
toTypeRefResult (row :. modInfo) = Just ReferenceResult
  { refResultFile = fromMaybe "" (modInfoSrcFile modInfo)
  , refResultModule = T.pack $ moduleNameString $ modInfoName modInfo
  , refResultSpan = SrcSpan
      { srcSpanFile = fromMaybe "" (modInfoSrcFile modInfo)
      , srcSpanStartLine = HieDb.typeRefSLine row
      , srcSpanStartCol = HieDb.typeRefSCol row
      , srcSpanEndLine = HieDb.typeRefELine row
      , srcSpanEndCol = HieDb.typeRefECol row
      }
  }

-- | Get information about a module
getModuleInfo :: HieDb -> Text -> IO (Maybe ModuleInfo)
getModuleInfo db modNameText = do
  let mn = mkModuleName (T.unpack modNameText)
  result <- HieDb.resolveUnitId db mn
  case result of
    Left _ -> pure Nothing
    Right unit -> do
      mRow <- HieDb.lookupHieFile db mn unit
      pure $ fmap toModuleInfo mRow

-- | Module information
data ModuleInfo = ModuleInfo
  { moduleInfoName :: Text
  , moduleInfoFile :: Maybe FilePath
  , moduleInfoHieFile :: FilePath
  }
  deriving stock (Eq, Show)

toModuleInfo :: HieModuleRow -> ModuleInfo
toModuleInfo row = ModuleInfo
  { moduleInfoName = T.pack $ moduleNameString $ modInfoName $ hieModInfo row
  , moduleInfoFile = modInfoSrcFile $ hieModInfo row
  , moduleInfoHieFile = hieModuleHieFile row
  }

-- | Get all indexed modules
getAllModules :: HieDb -> IO [ModuleInfo]
getAllModules db = do
  rows <- getAllIndexedMods db
  pure $ map toModuleInfo rows

-- | Get exports of a module
getExports :: HieDb -> Text -> IO [Text]
getExports db modNameText = do
  let mn = mkModuleName (T.unpack modNameText)
  exports <- HieDb.getExportsForModule db mn
  pure $ map (T.pack . occNameString . HieDb.exportName) exports

--------------------------------------------------------------------------------
-- Symbol Information
--------------------------------------------------------------------------------

-- | Symbol information
data SymbolInfo = SymbolInfo
  { symbolInfoName :: Text
  , symbolInfoKind :: Text
  , symbolInfoSpan :: SrcSpan
  }
  deriving stock (Eq, Show)

--------------------------------------------------------------------------------
-- Semantic Diagnostics
--------------------------------------------------------------------------------

-- | A semantic diagnostic from HIE analysis
data SemanticDiagnostic = SemanticDiagnostic
  { semDiagFile :: FilePath
  , semDiagSpan :: SrcSpan
  , semDiagMessage :: Text
  , semDiagSeverity :: Severity
  , semDiagCode :: Text
  }
  deriving stock (Eq, Show)

-- | Run semantic analysis on the indexed codebase
runSemanticAnalysis :: HieDb -> IO [SemanticDiagnostic]
runSemanticAnalysis db = do
  unusedExports <- findUnusedExports db
  unusedDefs <- findUnusedDefinitions db
  pure $ unusedExports ++ unusedDefs

-- | Find exports that are not used anywhere else in the codebase
findUnusedExports :: HieDb -> IO [SemanticDiagnostic]
findUnusedExports db = do
  mods <- getAllIndexedMods db
  concat <$> forM mods (\modRow -> do
    let mn = modInfoName $ hieModInfo modRow
        srcFile = modInfoSrcFile $ hieModInfo modRow
    exports <- HieDb.getExportsForModule db mn

    -- For each export, check if it's referenced anywhere
    unusedList <- forM exports $ \export -> do
      let occName = HieDb.exportName export
          exportMod = HieDb.exportMod export
      refs <- HieDb.findReferences db False occName (Just exportMod) Nothing []

      -- If no external references, it might be unused
      let externalRefs = filter (\(_ :. m) -> modInfoName m /= mn) refs
      if null externalRefs
        then pure $ Just SemanticDiagnostic
          { semDiagFile = fromMaybe "" srcFile
          , semDiagSpan = SrcSpan
              { srcSpanFile = fromMaybe "" srcFile
              , srcSpanStartLine = 1
              , srcSpanStartCol = 1
              , srcSpanEndLine = 1
              , srcSpanEndCol = 1
              }
          , semDiagMessage = "Export '" <> T.pack (occNameString occName) <> "' has no external references"
          , semDiagSeverity = Warning
          , semDiagCode = "semantic/unused-export"
          }
        else pure Nothing

    pure $ catMaybes unusedList)

-- | Find definitions that are not referenced anywhere
-- Note: This uses searchDef which searches globally, then filters by module.
-- For large codebases, this may need optimization.
findUnusedDefinitions :: HieDb -> IO [SemanticDiagnostic]
findUnusedDefinitions db = do
  -- Search for all definitions using a wildcard pattern
  -- searchDef with empty string matches "_:%" which gets all definitions
  allDefs <- HieDb.searchDef db ""

  -- Group by module and check references
  concat <$> forM allDefs (\(defRow :. modInfo) -> do
    let occName = defNameOcc defRow
        mn = modInfoName modInfo
        unit = modInfoUnit modInfo

    -- Find all references to this definition
    refs <- HieDb.findReferences db False occName (Just mn) (Just unit) []

    -- Filter out self-references (definition site)
    let nonSelfRefs = filter (isNotSelfRef defRow) refs

    if null nonSelfRefs
      then pure [SemanticDiagnostic
        { semDiagFile = fromMaybe "" (modInfoSrcFile modInfo)
        , semDiagSpan = SrcSpan
            { srcSpanFile = fromMaybe "" (modInfoSrcFile modInfo)
            , srcSpanStartLine = defSLine defRow
            , srcSpanStartCol = defSCol defRow
            , srcSpanEndLine = defELine defRow
            , srcSpanEndCol = defECol defRow
            }
        , semDiagMessage = "Definition '" <> T.pack (occNameString occName) <> "' is never used"
        , semDiagSeverity = Warning
        , semDiagCode = "semantic/unused-definition"
        }]
      else pure [])

isNotSelfRef :: DefRow -> Res RefRow -> Bool
isNotSelfRef defRow (refRow :. _) =
  not (defSLine defRow == refSLine refRow && defSCol defRow == refSCol refRow)

--------------------------------------------------------------------------------
-- HIE Data for Unused Detection
--------------------------------------------------------------------------------

-- | HIE data for a file, used by unused detection
-- This is a lightweight representation for the Unused module
data HieData = HieData
  { hieFile    :: FilePath
  , hieModule  :: Text
  , _hieImports :: [QualifiedName]
  , _hieExports :: [QualifiedName]
  }
  deriving stock (Eq, Show)

-- | Get imports from HIE data
hieImports :: HieData -> [QualifiedName]
hieImports = _hieImports

-- | Get exports from HIE data
hieExports :: HieData -> [QualifiedName]
hieExports = _hieExports

-- | Load HIE data from a directory
-- This is a placeholder implementation that returns empty data
-- A full implementation would use hiedb to query indexed HIE files
loadHieFiles :: FilePath -> IO [HieData]
loadHieFiles _dir = do
  -- TODO: Implement full HIE file loading
  -- For now, return empty list as placeholder
  -- Full implementation would:
  -- 1. Initialize/open hiedb at a standard location
  -- 2. Index any new HIE files
  -- 3. Query for all module info and convert to HieData
  pure []
