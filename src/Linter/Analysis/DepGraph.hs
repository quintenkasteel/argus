{-# LANGUAGE StrictData #-}

-- |
-- Module      : Linter.Analysis.DepGraph
-- Description : Dependency graph for cross-module analysis
-- Copyright   : (c) 2024
-- License     : MIT
--
-- This module provides a dependency graph data structure and algorithms
-- for analyzing code dependencies across modules, including Template Haskell
-- reference tracking.
module Linter.Analysis.DepGraph
  ( -- * Graph types
    DepGraph (..)
  , DepNode (..)
  , DepEdge (..)
  , EdgeKind (..)

    -- * Construction
  , emptyGraph
  , buildGraph
  , addNode
  , addEdge
  , addRoot

    -- * Analysis
  , reachableFrom
  , unreachableNodes
  , findCycles
  , topologicalSort

    -- * Template Haskell support
  , addThReference
  , markThGenerated
  , getThDependencies
  ) where

import Algebra.Graph.Labelled qualified as G
import Data.Map.Strict (Map)
import Data.Map.Strict qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set
import Data.Text (Text)

import Linter.Types

--------------------------------------------------------------------------------
-- Graph Types
--------------------------------------------------------------------------------

-- | Kind of dependency edge
data EdgeKind
  = DirectReference     -- ^ Direct reference in code
  | TypeDependency      -- ^ Type-level dependency
  | ImportDependency    -- ^ Import dependency
  | ExportDependency    -- ^ Export dependency
  | ThQuote             -- ^ Template Haskell quote
  | ThSplice            -- ^ Template Haskell splice result
  | InstanceDependency  -- ^ Type class instance
  deriving stock (Eq, Ord, Show)

-- | A node in the dependency graph
data DepNode = DepNode
  { dnSymbol      :: Symbol     -- ^ The symbol
  , dnIsRoot      :: Bool       -- ^ Is this a root node?
  , dnIsThGen     :: Bool       -- ^ Generated by Template Haskell?
  , dnModule      :: Text       -- ^ Containing module
  }
  deriving stock (Eq, Ord, Show)

-- | An edge in the dependency graph
data DepEdge = DepEdge
  { deKind   :: EdgeKind  -- ^ Kind of dependency
  , deSpan   :: SrcSpan   -- ^ Where the reference occurs
  }
  deriving stock (Eq, Ord, Show)

-- | The dependency graph
data DepGraph = DepGraph
  { dgNodes      :: Map QualifiedName DepNode
  , dgEdges      :: Map QualifiedName [(QualifiedName, DepEdge)]
  , dgRoots      :: Set QualifiedName
  , dgThRefs     :: Map QualifiedName [QualifiedName]  -- TH splice -> referenced names
  , dgReverse    :: Map QualifiedName [QualifiedName]  -- Reverse edges for lookup
  }
  deriving stock (Eq, Show)

--------------------------------------------------------------------------------
-- Construction
--------------------------------------------------------------------------------

-- | Empty dependency graph
emptyGraph :: DepGraph
emptyGraph = DepGraph Map.empty Map.empty Set.empty Map.empty Map.empty

-- | Build a dependency graph from HIE data
buildGraph :: [Symbol] -> [(Symbol, Symbol, EdgeKind, SrcSpan)] -> Set QualifiedName -> DepGraph
buildGraph symbols edges roots =
  let graph = foldr addSymbolNode emptyGraph symbols
      graphWithEdges = foldr addEdgeFromTuple graph edges
  in graphWithEdges { dgRoots = roots }
  where
    addSymbolNode sym g = addNode (symbolName sym) (mkNode sym) g

    mkNode sym = DepNode
      { dnSymbol = sym
      , dnIsRoot = symbolName sym `Set.member` roots
      , dnIsThGen = False
      , dnModule = fromMaybe "" $ qnModule (symbolName sym)
      }

    addEdgeFromTuple (from, to, kind, span) g =
      addEdge (symbolName from) (symbolName to) (DepEdge kind span) g

    fromMaybe def Nothing = def
    fromMaybe _ (Just x) = x

-- | Add a node to the graph
addNode :: QualifiedName -> DepNode -> DepGraph -> DepGraph
addNode name node g = g { dgNodes = Map.insert name node (dgNodes g) }

-- | Add an edge to the graph
addEdge :: QualifiedName -> QualifiedName -> DepEdge -> DepGraph -> DepGraph
addEdge from to edge g = g
  { dgEdges = Map.insertWith (++) from [(to, edge)] (dgEdges g)
  , dgReverse = Map.insertWith (++) to [from] (dgReverse g)
  }

-- | Mark a node as a root
addRoot :: QualifiedName -> DepGraph -> DepGraph
addRoot name g = g
  { dgRoots = Set.insert name (dgRoots g)
  , dgNodes = Map.adjust (\n -> n { dnIsRoot = True }) name (dgNodes g)
  }

--------------------------------------------------------------------------------
-- Analysis
--------------------------------------------------------------------------------

-- | Find all nodes reachable from the roots
reachableFrom :: DepGraph -> Set QualifiedName -> Set QualifiedName
reachableFrom g roots = go Set.empty (Set.toList roots)
  where
    go visited [] = visited
    go visited (n:ns)
      | n `Set.member` visited = go visited ns
      | otherwise =
          let edges = Map.findWithDefault [] n (dgEdges g)
              neighbors = map fst edges
          in go (Set.insert n visited) (neighbors ++ ns)

-- | Find all nodes not reachable from roots
unreachableNodes :: DepGraph -> Set QualifiedName
unreachableNodes g =
  let allNodes = Set.fromList $ Map.keys (dgNodes g)
      reachable = reachableFrom g (dgRoots g)
  in Set.difference allNodes reachable

-- | Find cycles in the graph
findCycles :: DepGraph -> [[QualifiedName]]
findCycles g = filter (not . null) $ map findCycleFrom (Map.keys (dgNodes g))
  where
    findCycleFrom start = go Set.empty [start]
      where
        go _ [] = []
        go visited (n:path)
          | n == start && length path > 1 = reverse path
          | n `Set.member` visited = []
          | otherwise =
              let edges = Map.findWithDefault [] n (dgEdges g)
                  neighbors = map fst edges
              in concatMap (\next -> go (Set.insert n visited) (next:n:path)) neighbors

-- | Topological sort of the graph
topologicalSort :: DepGraph -> [QualifiedName]
topologicalSort g = reverse $ snd $ go Set.empty [] (Map.keys (dgNodes g))
  where
    go visited sorted [] = (visited, sorted)
    go visited sorted (n:ns)
      | n `Set.member` visited = go visited sorted ns
      | otherwise =
          let edges = Map.findWithDefault [] n (dgEdges g)
              neighbors = map fst edges
              (visited', sorted') = go (Set.insert n visited) sorted neighbors
          in go visited' (n : sorted') ns

--------------------------------------------------------------------------------
-- Template Haskell Support
--------------------------------------------------------------------------------

-- | Add a Template Haskell reference
addThReference :: QualifiedName -> [QualifiedName] -> DepGraph -> DepGraph
addThReference splice refs g = g
  { dgThRefs = Map.insert splice refs (dgThRefs g)
  , dgEdges = foldr (\ref -> Map.insertWith (++) splice [(ref, thEdge)]) (dgEdges g) refs
  }
  where
    thEdge = DepEdge ThSplice noSrcSpan

-- | Mark a symbol as TH-generated
markThGenerated :: QualifiedName -> DepGraph -> DepGraph
markThGenerated name g = g
  { dgNodes = Map.adjust (\n -> n { dnIsThGen = True }) name (dgNodes g)
  }

-- | Get all dependencies introduced by Template Haskell
getThDependencies :: DepGraph -> Map QualifiedName [QualifiedName]
getThDependencies = dgThRefs
