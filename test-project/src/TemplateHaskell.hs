{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE OverloadedStrings #-}
-- | Examples of Template Haskell usage for Argus TH analysis
module TemplateHaskell where

import Data.Aeson.TH (deriveJSON, defaultOptions, Options(..))
import Language.Haskell.TH (Q, Exp, runQ)

-- =============================================================================
-- Types that will have instances generated via TH
-- =============================================================================

-- | User data type - will have JSON instances derived
data User = User
  { userId   :: Int
  , userName :: String
  , userAge  :: Int
  } deriving (Show, Eq)

-- | Config data type - will have JSON instances derived
data Config = Config
  { cfgHost :: String
  , cfgPort :: Int
  , cfgDebug :: Bool
  } deriving (Show, Eq)

-- | Nested data type - more complex TH derivation
data Response a = Response
  { respStatus :: Int
  , respMessage :: String
  , respData :: Maybe a
  } deriving (Show, Eq)

-- =============================================================================
-- Template Haskell splices for JSON derivation
-- =============================================================================

-- | Derive JSON instances for User
-- This generates toJSON and parseJSON
$(deriveJSON defaultOptions ''User)

-- | Derive JSON instances for Config with custom options
$(deriveJSON defaultOptions { fieldLabelModifier = drop 3 } ''Config)

-- | Derive JSON instances for Response
$(deriveJSON defaultOptions { fieldLabelModifier = drop 4, omitNothingFields = True } ''Response)

-- =============================================================================
-- Functions that use the generated instances
-- These identifiers (toJSON, parseJSON) are generated by TH
-- Argus should recognize them as "used via TH"
-- =============================================================================

-- | Serialize a user to JSON
-- Note: toJSON is generated by $(deriveJSON ...)
serializeUser :: User -> String
serializeUser u = show u  -- In reality would use encode/toJSON

-- | Deserialize a config from JSON
-- Note: parseJSON is generated by $(deriveJSON ...)
deserializeConfig :: String -> Maybe Config
deserializeConfig _ = Just $ Config "localhost" 8080 False

-- =============================================================================
-- Functions that might appear "unused" but are exported via TH
-- =============================================================================

-- | This might look unused but could be referenced by TH-generated code
helperForTH :: Int -> String
helperForTH n = "value: " ++ show n

-- | Another potential TH helper
formatField :: String -> String
formatField s = map (\c -> if c == '_' then '-' else c) s

-- =============================================================================
-- Example data for testing
-- =============================================================================

-- | Sample user for testing
sampleUser :: User
sampleUser = User 1 "Alice" 30

-- | Sample config for testing
sampleConfig :: Config
sampleConfig = Config "example.com" 443 True

-- | Sample response for testing
sampleResponse :: Response User
sampleResponse = Response 200 "OK" (Just sampleUser)
