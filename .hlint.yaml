# HLint configuration file
# https://github.com/ndmitchell/hlint

- arguments: [--color=auto, -XStrictData]

# Blacklist some functions by default.
- functions:
    - { name: unsafePerformIO, within: [Data.Scientific.Exts.attemptUnsafeArithmetic] }
    - { name: unsafeCoerce, within: [] }
    - { name: head, within: [] }
    - { name: tail, within: [] }
    - { name: init, within: [] }
    - { name: last, within: [] }
    - { name: companyNameOld, within: [], message: only for migration purposes }
    - { name: featureFlagsOld, within: [], message: only for migration purposes }
    - { name: renderFlagsOld, within: [], message: only for migration purposes }
    - { name: oneTrustCookieModalIdOld, within: [], message: only for migration purposes }
    - { name: samlSettingsOld, within: [], message: only for migration purposes }
    - { name: samlCmsSettingsOld, within: [], message: only for migration purposes }
    - { name: afasAuthSettingsOld, within: [], message: only for migration purposes }
    - { name: plausibleSettingsOld, within: [], message: only for migration purposes }
    - { name: hireserveSettingsOld, within: [], message: only for migration purposes }
    - { name: invalidateLoginTokenSecondsOld, within: [], message: only for migration purposes }
    - { name: uploadDirectoryOld, within: [], message: only for migration purposes }
    - { name: sessionTimeoutSecondsOld, within: [], message: only for migration purposes }
    - { name: appDetailedRequestLoggingOld, within: [], message: only for migration purposes }
    - { name: appShouldLogAllOld, within: [], message: only for migration purposes }
    - { name: sessionCookieOld, within: [], message: only for migration purposes }
    - { name: sessionCookieSameSiteStrictOld, within: [], message: only for migration purposes }
    - { name: <$>, within: [], message: Use fmap instead of <$> }
    - { name: <*>, within: [], message: Use fmap instead of applicative }
#  - {name: fromJust, within: []}

# Replace a $ b $ c with a . b $ c
- group: { name: dollar, enabled: true }

# Generalise map to fmap, ++ to <>
- group: { name: generalise, enabled: true }

# Change the severity of the default group to warning
- warn: { group: { name: default } }

# Brackets generally improve readability
- ignore: { name: Redundant bracket due to operator fixities }
- ignore: { name: Redundant bracket }

# Ignore hint to rewrite functions with infix notation as this is ofter a lot less readable
- ignore: { name: Avoid lambda using `infix` }

# Ignore the highly noisy module export list hint
- ignore: { name: Use explicit module export list }

# Ignore some builtin hints
- ignore: { name: Redundant id } # Conflicts with entity.id via record dot syntax

# Functor law
- warning:
    { lhs: fmap f (fmap g x), rhs: fmap (f . g) x, name: "Functor law, use function comprehension" }
- warning: { lhs: fmap id, rhs: id, name: "Functor law, use function comprehension" }
- warning: { lhs: id <$> x, rhs: x, name: "Functor law, use function comprehension" }
- warning: { lhs: x <&> id, rhs: x, name: "Functor law, use function comprehension" }
- ignore: { name: Functor law }

# Change the severity of hints we donâ€™t want to fail CI for
- suggest: { name: Eta reduce }

- suggest: { name: Use lambda-case }

# While I think DerivingStrategies is good, it's too noisy to suggest by default
- ignore: { name: Use DerivingStrategies }

# hlint has issues with QuantifiedConstraints (see https://github.com/ndmitchell/hlint/issues/759)
# Once the above is fixed, we can drop this error.
- ignore: { name: Parse error }

# hlint suggests to use foldMap instead of maybe []. maybe [] is better to understand.
- ignore: { name: Use foldMap }

# hlint suggests to use mapMaybe instead of maybe []. maybe [] is better to understand.

- ignore: { name: Use mapMaybe }

# hlint suggests underscores in numbers.

- ignore: { name: Use underscore }

# hlint suggests to use tuple sections.

- ignore: { name: Use tuple-section }

# hlint suggests to use tuple sections.

- ignore: { name: Use section }

# hlint to just use pure for Traversable law

- ignore: { name: Traversable law }

- ignore: { name: Use <&> }
# hlint suggests to use list comprehension. If then else is better to understand.
- ignore: { name: Use list comprehension }

# hlint and record dot syntax don't work nicely together:
# hlint warns about TypeApplications being unused, but it is necessary for record
# dot syntax to work
- ignore: { name: Unused LANGUAGE pragma }

# Functor law

- warning:
    { lhs: fmap f (fmap g x), rhs: fmap (f . g) x, name: "Functor law, use function comprehension" }
- warning: { lhs: fmap id, rhs: id, name: "Functor law, use function comprehension" }
- warning: { lhs: id <$> x, rhs: x, name: "Functor law, use function comprehension" }
- warning: { lhs: x <&> id, rhs: x, name: "Functor law, use function comprehension" }
- ignore: { name: Functor law }
- ignore: { name: Redundant ^. }

# hlint is too paranoid about NonEmpty functions (https://github.com/ndmitchell/hlint/issues/787)

# Our customized warnings

# AMP fallout
- warning: { lhs: mapM, rhs: traverse, name: Generalize mapM }
- warning: { lhs: mapM_, rhs: traverse_, name: Generalize mapM_ }
- warning: { lhs: forM, rhs: for, name: Generalize forM }
- warning: { lhs: forM_, rhs: for_, name: Generalize forM_ }
- warning: { lhs: sequence, rhs: sequenceA, name: Generalize sequence }
- warning: { lhs: sequence_, rhs: sequenceA_, name: Generalize sequence_ }

# Terms
- warning: { lhs: termFAnnotation . unTerm, rhs: termAnnotation, name: Use termAnnotation }
- warning: { lhs: termFOut . unTerm, rhs: termOut, name: Use termOut }
- warning: { lhs: project . termOut, rhs: projectTerm, name: Use projectTerm }

# Conveniences
- warning: { lhs: either (const a) id, rhs: fromRight a, name: use fromRight }
- warning: { lhs: either id (const a), rhs: fromLeft a, name: use fromLeft }

# Readability
- warning: { lhs: a =<< f, rhs: f >>= a, name: use >>= for readability }

# Applicative style
- warning: { lhs: f <$> pure a <*> b, rhs: f a <$> b, name: Avoid redundant pure }
- warning: { lhs: f <$> pure a <* b, rhs: f a <$ b, name: Avoid redundant pure }

# Lenses

# Refactor
- warning: { lhs: Control.Monad.void a, rhs: void a, name: use void from Prelude }
- warning: { lhs: Control.Monad.when a, rhs: when a, name: use when from Prelude }
- warning: { lhs: Tuple.fst a, rhs: fst a, name: use fst from Prelude }
- warning: { lhs: Tuple.snd a, rhs: snd a, name: use snd from Prelude }
- warning: { lhs: f <$> a, rhs: fmap f a, name: Use fmap }

# Modules
- modules:
    - { name: [RIO, Prelude, ClassyPrelude], importStyle: unqualified }
    - { name: ClassyPrelude.Yesod, importStyle: explicitOrQualified, as: Yesod, asRequired: false }
    - { name: [Flow], importStyle: explicit }
    # - { name: "*", importStyle: explicitOrQualified, qualifiedStyle: pre }
