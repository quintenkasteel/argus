[{"code":"imports/unused","hasFix":true,"message":"Unused imports from Control.Monad: replicateM","severity":"Warning"},{"code":"imports/unused","hasFix":true,"message":"Unused imports from Data.Functor: <&>","severity":"Warning"},{"code":"modernize/applicative","hasFix":true,"message":"'sequenceA' is more general (works with any Applicative). Replace with: useSequence actions = sequenceA actions","severity":"Info"},{"code":"modernize/applicative","hasFix":false,"message":"'(<*>)' is the Applicative operator equivalent of 'ap'. Replace with: (<*>)","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'fmap' is the Functor equivalent of 'liftM'. Replace with: useLiftM f m = fmap f m","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'liftA2' is the Applicative equivalent of 'liftM2'. Replace with: useLiftM2 f m1 m2 = liftA2 f m1 m2","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: bindReturnFunc f m = m >>= \\x -> pure (f x)","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: bindReturnUnit m = m >> pure ()","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: bindWithReturn f x = pure x >>= f","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: return (map transform items)","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: return x","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: return x","severity":"Suggestion"},{"code":"modernize/applicative","hasFix":true,"message":"'pure' is more general than 'return' (Applicative vs Monad). Replace with: useReturn x = pure x","severity":"Suggestion"},{"code":"modernize/traversable","hasFix":true,"message":"'for' is more general than 'forM'. Replace with: useForM xs f = for xs f","severity":"Info"},{"code":"modernize/traversable","hasFix":true,"message":"'for_' is more general than 'forM_'. Replace with: useForM_ xs f = for_ xs f","severity":"Info"},{"code":"modernize/traversable","hasFix":true,"message":"'traverse' is more general than 'mapM'. Replace with: processItems processor items = traverse processor items","severity":"Info"},{"code":"modernize/traversable","hasFix":true,"message":"'traverse' is more general than 'mapM'. Replace with: useMapM f xs = traverse f xs","severity":"Info"},{"code":"modernize/traversable","hasFix":true,"message":"'traverse' is more general than 'mapM'. Replace with: validItems <- traverse validate items","severity":"Info"},{"code":"modernize/traversable","hasFix":true,"message":"'traverse_' is more general than 'mapM_'. Replace with: useMapM_ f xs = traverse_ f xs","severity":"Info"},{"code":"performance/allocation","hasFix":false,"message":"Unused lambda argument still captures closure environment. Use const or restructure to avoid closure capture","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"Unused lambda argument still captures closure environment. Use const or restructure to avoid closure capture","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"Unused lambda argument still captures closure environment. Use const or restructure to avoid closure capture","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"sequence collects all results before returning. Use sequence_ if results aren't needed, or streaming","severity":"Suggestion"}]