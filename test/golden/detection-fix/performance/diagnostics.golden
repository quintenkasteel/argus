[{"code":"extension/missing","hasFix":true,"message":"Extension PatternSynonyms appears to be needed","severity":"Warning"},{"code":"modernize/applicative","hasFix":true,"message":"'sequenceA' is more general (works with any Applicative). Replace with: alternativeCollect f xs = sequenceA $ map f xs","severity":"Info"},{"code":"modernize/applicative","hasFix":true,"message":"'sequenceA' is more general (works with any Applicative). Replace with: collectResults f xs = sequenceA (map f xs)","severity":"Info"},{"code":"performance/algorithm","hasFix":true,"message":"head . sort is O(n log n), minimum is O(n) (Complexity: O(n log n) → O(n)). Use minimum for O(n) performance","severity":"Warning"},{"code":"performance/algorithm","hasFix":true,"message":"last . sort is O(n log n), maximum is O(n) (Complexity: O(n log n) → O(n)). Use maximum for O(n) performance","severity":"Warning"},{"code":"performance/algorithm","hasFix":true,"message":"length xs /= 0 traverses entire list to check non-emptiness (Complexity: O(n) → O(1)). Use 'not (null xs)' for O(1) check","severity":"Warning"},{"code":"performance/algorithm","hasFix":true,"message":"length xs == 0 traverses entire list to check emptiness (Complexity: O(n) → O(1)). Use 'null xs' for O(1) check","severity":"Warning"},{"code":"performance/algorithm","hasFix":true,"message":"length xs > 0 traverses entire list to check non-emptiness (Complexity: O(n) → O(1)). Use 'not (null xs)' for O(1) check","severity":"Warning"},{"code":"performance/algorithm","hasFix":false,"message":"nub is O(n²) as it uses Eq comparison (Complexity: O(n²)). Use nubOrd from containers or Data.List.Extra for O(n log n), or use Set/HashSet","severity":"Warning"},{"code":"performance/allocation","hasFix":false,"message":"File has 9 map and 2 filter calls - consider combining chained operations. Look for map f . map g patterns to combine into map (f . g)","severity":"Suggestion"},{"code":"performance/allocation","hasFix":true,"message":"all id is equivalent to and. Use 'and' for clearer intent","severity":"Suggestion"},{"code":"performance/allocation","hasFix":true,"message":"any id is equivalent to or. Use 'or' for clearer intent","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"filter p . filter q allocates intermediate list. Combine into filter (\\x -> p x && q x)","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"map f . map g allocates intermediate list. Combine into map (f . g)","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"map f . map g allocates intermediate list. Combine into map (f . g)","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"replicateM collects all results in memory. Use replicateM_ if results aren't needed, or stream","severity":"Suggestion"},{"code":"performance/allocation","hasFix":true,"message":"reverse . sort allocates twice. Use sortBy (flip compare) or sortDown","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"sequence collects all results before returning. Use sequence_ if results aren't needed, or streaming","severity":"Suggestion"},{"code":"performance/allocation","hasFix":false,"message":"sequence collects all results before returning. Use sequence_ if results aren't needed, or streaming","severity":"Suggestion"},{"code":"performance/allocation","hasFix":true,"message":"concat (map f xs) allocates intermediate list of lists. Use concatMap f xs for single-pass","severity":"Warning"},{"code":"performance/allocation","hasFix":true,"message":"concat (map f xs) allocates intermediate list of lists. Use concatMap f xs for single-pass","severity":"Warning"},{"code":"performance/allocation","hasFix":true,"message":"concat . map allocates intermediate list of lists. Use concatMap for single-pass","severity":"Warning"},{"code":"performance/allocation","hasFix":true,"message":"concat . map allocates intermediate list of lists. Use concatMap for single-pass","severity":"Warning"},{"code":"performance/allocation","hasFix":true,"message":"mconcat (map f xs) allocates intermediate list. Use foldMap f xs for single-pass","severity":"Warning"},{"code":"performance/allocation","hasFix":true,"message":"mconcat . map allocates intermediate list. Use foldMap for single-pass","severity":"Warning"},{"code":"performance/lazy","hasFix":false,"message":"Data.Map is lazy in values - can accumulate thunks. Use Data.Map.Strict unless you need lazy evaluation","severity":"Suggestion"},{"code":"redundant/double-reverse-compose","hasFix":true,"message":"'reverse . reverse' is equivalent to 'id'","severity":"Warning"},{"code":"redundant/map-id","hasFix":true,"message":"'map id x' is equivalent to 'x'","severity":"Warning"},{"code":"space-leak/lazy-fold","hasFix":true,"message":"foldl accumulates thunks that can cause stack overflow on large lists. Use foldl' from Data.List for strict left fold","severity":"Warning"},{"code":"space-leak/lazy-fold","hasFix":true,"message":"foldl accumulates thunks that can cause stack overflow on large lists. Use foldl' from Data.List for strict left fold","severity":"Warning"},{"code":"space-leak/lazy-fold","hasFix":true,"message":"foldl accumulates thunks that can cause stack overflow on large lists. Use foldl' from Data.List for strict left fold","severity":"Warning"},{"code":"space-leak/lazy-io","hasFix":true,"message":"Prelude.readFile uses lazy IO. Use Data.Text.IO.readFile or Data.ByteString.readFile","severity":"Suggestion"}]